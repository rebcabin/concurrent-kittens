(ns intrinsic-function.core
  (:gen-class)
  (:require [clojure.spec.alpha            :as    s       ]
            [clojure.pprint                :refer [pprint]]
            [clojure.set                   :as    set     ]
            [blaster.clj-fstring           :refer [f-str] ]
            #_[clojure.data.zip              :as    dz      ]
            #_[clojure.spec.gen.alpha        :as    gen     ]
            #_[clojure.spec.test.alpha       :as    stest   ]
            #_[clojure.test.check.generators :as    tgen    ]
            #_[clojure.set                   :as    set     ]
            #_[pathetic.core                 :as    path    ]
            #_[asr.lpython                   :as    lpython]))


(s/check-asserts true)


;;; The main source of complexity is variadic pars. Otherwise,
;;; this is a direct transcription of the kitten calculus from the
;;; companion paper. See 'core-test.clj' for lots of samples.


;;  ___         _               _
;; | _ \_ _ ___| |_ ___  __ ___| |___
;; |  _/ '_/ _ \  _/ _ \/ _/ _ \ (_-<
;; |_| |_| \___/\__\___/\__\___/_/__/


(defprotocol Names
  (free-names  [this])
  (bound-names [this])
  (recursor    [this bound-or-free]))


(defprotocol Rename
  (rename-bound [this, old-, new-]))


(defprotocol Subst
  (subst-free [this x-for y]))


(defprotocol Flatten
  (flatten-pars [this]))


(defprotocol Children
  (children [this]))


(defprotocol Path
  (path-key [this]))


;;  _  ___ _   _               ___      _         _
;; | |/ (_) |_| |_ ___ _ _    / __|__ _| |__ _  _| |_  _ ___
;; | ' <| |  _|  _/ -_) ' \  | (__/ _` | / _| || | | || (_-<
;; |_|\_\_|\__|\__\___|_||_|  \___\__,_|_\__|\_,_|_|\_,_/__/
;;
;; The "type" of a kitten is called a "kit." I didn't want the
;; heavily over-used words "type," "kind," "sort," etc. A "kit"
;; can be one of :nap, :pars, :par, :hear, :say, :channel,
;; :repeat-. :Pars is not in the kitten grammar in the little PDF.
;; Pars is just a flattened nest of one or more par's. But it
;; might as well be part of the grammar. It's not fundamentally a
;; different kind of thing. The children of a pars are its "kits."
;;
;; We'll add :name to the list of :kit's and to the protocols. By
;; doing so, we expose the inconvenient fact that names are not
;; part of the kitten grammar, even though we call them a "kit,"
;; as a kludge, so we can serialize them to vectors for the zipper
;; library. They're an undefined, outer kind of thing that come
;; from an infinite well. This inconvenient fact is exactly
;; the "kludge" that RhoLang solves.


;; -+-+-+-
;;  n a p
;; -+-+-+-

;; The reason for the println's below is that the CIDER debugger
;; in Emacs does not seem to work on protocols (not surprising, as
;; they are methods on generated bytecode classes in Java).

(defrecord nap     []

  Names     (free-names  [_] #{})  (bound-names [_] #{})

  Rename    (rename-bound [this, _, _]  this)

  Subst     (subst-free   [this, _, _]  this)

  Flatten   (flatten-pars [this] this)

  Children  (children [_] [])

  Path      (path-key [this]          [:nap]))


;; -+-+-+-+-
;;  p a r s
;; -+-+-+-+-
;; variadic par


(defrecord pars    [kits]

  Names     (recursor  [_ bf] (reduce #(into %1 (bf %2)) #{} kits))
  (free-names  [this]  (recursor this free-names))
  (bound-names [this]  (recursor this bound-names))

  Rename    (rename-bound [_, old-, new-]
              (pars. (vec (map #(rename-bound % old- new-) kits))))

  Subst     (subst-free [_, x-for, y]
              (pars. (vec (map #(subst-free % x-for, y) kits))))

  Flatten   (flatten-pars [this]
              (pars. (vec (flatten (map flatten-pars kits)))))

  Children  (children [_]    kits)

  Path      (path-key [this]
              [:pars :kits]))


;;; See https://clojure.org/guides/spec.
(s/def ::pars
  (s/and (s/keys :req-un [::kits])
         #(vector? (:kits %))))


;; -+-+-+-
;;  p a r
;; -+-+-+-
;; dyadic (canonical) par


(defrecord par     [K L]

  Names     (recursor [_ bf]  (set/union (bf K) (bf L)))
  (free-names  [this]  (recursor this free-names))
  (bound-names [this]  (recursor this bound-names))

  Rename    (rename-bound [_, old-, new-]
              (par. (rename-bound K old- new-) (rename-bound L old- new-)))

  Subst     (subst-free [_, x-for, y]
              (par. (subst-free K x-for y) (subst-free L x-for y)))

  ;; To flatten a par:
  ;; 1. Flatten each of its children, K & L, removing every par.
  ;; 2. Each child is either a pars or not. Iff a pars, its :kits
  ;;    are non-nil.
  ;; 3. Iff both are pars, concat their kits into a new pars.
  ;; 4. Iff one is pars and the other not, concat the non-pars
  ;;    with the kits of the pars.
  ;; 5. Else, kits are a vector of the two parts

  Flatten
  (flatten-pars [this]
    (let [kf  (flatten-pars K)          ; everything under is converted
          kfk (:kits kf)
          lf  (flatten-pars L)
          lfk (:kits lf)
          new-kits
          (cond
            (and (nil? kfk) (nil? lfk)) [kf lf]
            (nil? kfk)                  (vec (concat [kf] lfk))
            (nil? lfk)                  (vec (concat kfk [lf]))
            :else                       (vec (concat kfk lfk)))]
      (pars. new-kits)))

  Children  (children [_]    [K L])

  Path      (path-key [this]  [:par :K :L]))


;; -+-+-+-+-
;;  h e a r
;; -+-+-+-+-

;;                  free bound continuation
(defrecord hear    [hear-chan msg   K]

  Names
  (free-names  [_] (set/union #{hear-chan} (set/difference (free-names K) #{msg})))
  (bound-names [_] (set/union #{msg}  (bound-names K)))

  Rename    (rename-bound [_, old-, new-]
              (assert (= old- msg)
                      (str (f-str "Old name {old-} must equal ")
                           (f-str "current message name {msg}.")))
              (hear. hear-chan  new-  (rename-bound K old- new-)))

  Subst     (subst-free [this, x-for, y]
              (cond

                (and (= hear-chan y) (= msg y)) ; false positive!
                (let [defake (gensym "g")]
                  (hear. x-for defake
                         (rename-bound y defake K)))

                (= hear-chan y)  (hear. x-for msg (subst-free K x-for y))

                (= msg y)   (hear. hear-chan x-for (subst-free K x-for y))

                :else this))

  Flatten
  (flatten-pars [_]  (hear. hear-chan msg (flatten-pars K)))

  Children  (children [_]    [K])

  Path      (path-key [this]  [:hear :K]))


;; -+-+-+-
;;  s a y
;; -+-+-+-

;;                  free free continuation
(defrecord say     [say-chan  msg  K]

  Names
  (free-names  [_] (set/union (set [say-chan msg]) (free-names K)))
  (bound-names [_] (bound-names K))

  Rename    (rename-bound [this, old-, new-]  this)

  Subst     (subst-free [this, x-for, y]

              (cond

                (and (= say-chan y) (= msg y))
                (say. x-for x-for (subst-free K x-for y))

                (= say-chan y) (say. x-for msg   (subst-free K x-for y))

                (= msg  y) (say. say-chan  x-for (subst-free K x-for y))

                :else this))

  Flatten   (flatten-pars [_]  (say. say-chan msg (flatten-pars K)))

  Children  (children [_]    [K])

  Path      (path-key [this]  [:say :K]))


;; -+-+-+-+-+-+-+-
;;  c h a n n e l
;; -+-+-+-+-+-+-+-


(defrecord channel [whisper-chan K]  ; like nu in the pi calculus

  Names
  (free-names  [_] (set/difference  (free-names K)  #{whisper-chan}))
  (bound-names [_] (set/union       #{whisper-chan} (bound-names K)))

  Rename    (rename-bound [_, old-, new-]
              (assert (= old- whisper-chan)
                      (str (f-str "Old name {old-} must equal ")
                           (f-str "current channel name {whisper-chan}.")))
              (channel. new- (subst-free K new- old-)))

  Subst     (subst-free [_, x-for y]
              (channel. whisper-chan (subst-free K x-for y)))

  Flatten   (flatten-pars [_]  (channel. whisper-chan  (flatten-pars K)))

  Children  (children [_]      [K])

  Path      (path-key [this]   [:channel :K]))


;; -+-+-+-+-+-+-+-
;;  r e p e a t -
;; -+-+-+-+-+-+-+-


(defrecord repeat- [K]  ; without hyphen, collides with built-in "repeat"

  Names
  (free-names  [_] (free-names K))
  (bound-names [_] (bound-names K))

  Rename    (rename-bound [this, old-, new-]  this)

  Subst     (subst-free [_, x-for y]
              (repeat-. (subst-free K x-for y)))

  Flatten
  (flatten-pars [_]  (repeat-. (flatten-pars K)))

  Children  (children [_]    [K])

  Path      (path-key [this]  [:repeat- :K]))


;;  ___ _      _     _  ___ _     ___
;; | __| |__ _| |_  | |/ (_) |_  / __|_ __  ___ __
;; | _|| / _` |  _| | ' <| |  _| \__ \ '_ \/ -_) _|
;; |_| |_\__,_|\__| |_|\_\_|\__| |___/ .__/\___\__|
;;                                   |_|


(s/def ::flat-kit
  (s/and #(not (instance? par %))
         #(every? (fn [child]
                    (s/valid? ::flat-kit child))
                  (children %))))


;;  _____                 ___            _ _         _
;; |_   _|  _ _ __  ___  | _ \_ _ ___ __| (_)__ __ _| |_ ___ ___
;;   | || || | '_ \/ -_) |  _/ '_/ -_) _` | / _/ _` |  _/ -_|_-<
;;   |_| \_, | .__/\___| |_| |_| \___\__,_|_\__\__,_|\__\___/__/
;;       |__/|_|


(def nap?     (partial instance? nap))
(def par?     (partial instance? par))
(def pars?    (partial instance? pars))
(def hear?    (partial instance? hear))
(def say?     (partial instance? say))
(def channel? (partial instance? channel))
(def repeat-? (partial instance? repeat-))

;; __   __               _      ___            _
;; \ \ / /__ _ _ _  _ __( )___ | _ ) ___  __ _| |_ ___
;;  \ V / -_) ' \ || (_-</(_-< | _ \/ _ \/ _` |  _(_-<
;;   \_/\___|_||_\_,_/__/ /__/ |___/\___/\__,_|\__/__/


;;; Support for the accompanying paper written in org-babel.
;;; Apparently need the following witnesses for org-babel
;;; (org-latex-export-to-pdf doesn't work well without them).


(def kit-1
  (say. 'x 'z (nap.)))
kit-1
;; => {:say-chan x, :msg z, :K {}}


(def kit-2
  (hear. 'x 'y
         (say. 'y 'x
               (hear. 'x 'y (nap.)))))
kit-2
;; => {:hear-chan x,
;;     :msg y,
;;     :K {:say-chan y, :msg x, :K {:hear-chan x, :msg y, :K {}}}}


(def kit-3
  (hear. 'z 'v
         (say. 'v 'v (nap.))))
kit-3
;; => {:hear-chan z, :msg v, :K {:say-chan v, :msg v, :K {}}}


(def whisper-boat
  (channel. 'x
            (par. kit-1
                  (par. kit-2 kit-3))))
whisper-boat
;; => {:whisper-chan x,
;;     :K
;;     {:K {:say-chan x, :msg z, :K {}},
;;      :L
;;      {:K
;;       {:hear-chan x,
;;        :msg y,
;;        :K {:say-chan y, :msg x, :K {:hear-chan x, :msg y, :K {}}}},
;;       :L {:hear-chan z, :msg v, :K {:say-chan v, :msg v, :K {}}}}}}


(def whisper-boat-2
  (channel. 'x
            (pars. [kit-1 kit-2 kit-3])))
whisper-boat-2
;; => {:whisper-chan x,
;;     :K
;;     {:kits
;;      [{:say-chan x, :msg z, :K {}}
;;       {:hear-chan x,
;;        :msg y,
;;        :K {:say-chan y, :msg x, :K {:hear-chan x, :msg y, :K {}}}}
;;       {:hear-chan z, :msg v, :K {:say-chan v, :msg v, :K {}}}]}}


;;  __  __      _      _    _
;; |  \/  |__ _| |_ __| |_ (_)_ _  __ _
;; | |\/| / _` |  _/ _| ' \| | ' \/ _` |
;; |_|  |_\__,_|\__\__|_||_|_|_||_\__, |
;;                                |___/


(defn find-top-pars

  ([flat-kit, path-so-far]
   (if (instance? pars flat-kit)
     {:path path-so-far,
      :top-pars flat-kit}
     (let [cs (children flat-kit)
           ps (map #(find-top-pars % path-so-far) cs)]
       (if (empty? cs)
         ()
         (let [fp (first ps)]
           (if (and fp (not (empty? fp)))
             {:path (conj path-so-far (path-key flat-kit))
              :top-pars (:top-pars fp)}
             () ))))))

  ([flat-kit]
   {:pre [(s/assert ::flat-kit flat-kit)]}
   (find-top-pars flat-kit [])))


(find-top-pars whisper-boat-2)
;; => {:path [[:channel :K]],
;;     :top-pars
;;     {:kits
;;      [{:say-chan x, :msg z, :K {}}
;;       {:hear-chan x,
;;        :msg y,
;;        :K {:say-chan y, :msg x, :K {:hear-chan x, :msg y, :K {}}}}
;;       {:hear-chan z, :msg v, :K {:say-chan v, :msg v, :K {}}}]}}


(defn find-top-says-and-hears
  [flat-kit]
  (let [fop   (find-top-pars flat-kit)
        ps    (:kits (:top-pars fop))
        says  (filter (partial instance? say)  ps)
        hears (filter (partial instance? hear) ps)]
    (if (not (empty? fop))
      (assoc fop :says says, :hears hears)
      ())))


(find-top-says-and-hears whisper-boat-2)
;; => {:path [[:channel :K]],
;;     :top-pars
;;     {:kits
;;      [{:say-chan x, :msg z, :K {}}
;;       {:hear-chan x,
;;        :msg y,
;;        :K {:say-chan y, :msg x, :K {:hear-chan x, :msg y, :K {}}}}
;;       {:hear-chan z, :msg v, :K {:say-chan v, :msg v, :K {}}}]},
;;     :says ({:say-chan x, :msg z, :K {}}),
;;     :hears
;;     ({:hear-chan x,
;;       :msg y,
;;       :K {:say-chan y, :msg x, :K {:hear-chan x, :msg y, :K {}}}}
;;      {:hear-chan z, :msg v, :K {:say-chan v, :msg v, :K {}}})}


(defn non-deterministic-say-hear-match
  [flat-kit]
  {:pre [(s/assert ::flat-kit flat-kit)]}
  (let [tsh (find-top-says-and-hears flat-kit)]
    (if (and (not (empty? tsh))
             (not (empty? (:says tsh)))
             (not (empty? (:hears tsh))))
      (let [match-say (first (:says tsh)) ; could be any
            match-hear (first (filter
                               #(= (:say-chan match-say)
                                   (:hear-chan %))
                               (:hears tsh)))]
        (assoc tsh :match-say match-say, :match-hear match-hear)
        )
      tsh)))

(non-deterministic-say-hear-match
 whisper-boat-2)
;; => {:path [[:channel :K]],
;;     :top-pars
;;     {:kits
;;      [{:say-chan x, :msg z, :K {}}
;;       {:hear-chan x,
;;        :msg y,
;;        :K {:say-chan y, :msg x, :K {:hear-chan x, :msg y, :K {}}}}
;;       {:hear-chan z, :msg v, :K {:say-chan v, :msg v, :K {}}}]},
;;     :says ({:say-chan x, :msg z, :K {}}),
;;     :hears
;;     ({:hear-chan x,
;;       :msg y,
;;       :K {:say-chan y, :msg x, :K {:hear-chan x, :msg y, :K {}}}}
;;      {:hear-chan z, :msg v, :K {:say-chan v, :msg v, :K {}}}),
;;     :match-say {:say-chan x, :msg z, :K {}},
;;     :match-hear
;;     {:hear-chan x,
;;      :msg y,
;;      :K {:say-chan y, :msg x, :K {:hear-chan x, :msg y, :K {}}}}}


(defn replace-kit
  [old new kits]
  (reduce #(conj %1 (if (= %2 old) new %2)) [] kits))


(defn match-subst-gobble
  [flat-kit]
  {:pre [(s/assert ::flat-kit flat-kit)]}
  (let [ndshm (non-deterministic-say-hear-match
               flat-kit)
        ms (:match-say  ndshm)
        mh (:match-hear ndshm)]
    (assert (= (:say-chan ms) (:hear-chan mh)))
    (if (and ms mh)
      (let [said (:msg ms)
            renamed (if ((bound-names mh) said)
                      (rename-bound mh said (gensym "g"))
                      mh)
            substd (subst-free renamed said (:msg mh))
            say-suffix  (:K ms)
            hear-suffix (:K substd)
            old-kits    (:kits (:top-pars ndshm))
            rs          (replace-kit ms say-suffix  old-kits)
            new-kits    (replace-kit mh hear-suffix rs)
            ;; TODO: Use path.
            gobbled     (channel. (:whisper-chan flat-kit) (pars. new-kits))
            ]
        gobbled)
      ndshm)))


whisper-boat-2
;; => {:whisper-chan x,
;;     :K
;;     {:kits
;;      [{:say-chan x, :msg z, :K {}}
;;       {:hear-chan x,
;;        :msg y,
;;        :K {:say-chan y, :msg x, :K {:hear-chan x, :msg y, :K {}}}}
;;       {:hear-chan z, :msg v, :K {:say-chan v, :msg v, :K {}}}]}}


(match-subst-gobble
 whisper-boat-2)
;; => {:whisper-chan x,
;;     :K
;;     {:kits
;;      [{}
;;       {:say-chan z, :msg x, :K {:hear-chan x, :msg z, :K {}}}
;;       {:hear-chan z, :msg v, :K {:say-chan v, :msg v, :K {}}}]}}


(match-subst-gobble
 (match-subst-gobble
  whisper-boat-2))
;; => {:whisper-chan x,
;;     :K
;;     {:kits
;;      [{}
;;       {:hear-chan x, :msg z, :K {}}
;;       {:say-chan x, :msg x, :K {}}]}}


(match-subst-gobble
 (match-subst-gobble
  (match-subst-gobble
   whisper-boat-2)))
;; => {:whisper-chan x, :K {:kits [{} {} {}]}}


(loop [boat whisper-boat-2]
  (if (every? #(= (nap.) %) (:kits (:K boat)))
    boat
    (recur (match-subst-gobble boat))))
;; => {:whisper-chan x, :K {:kits [{} {} {}]}}


(defn -main
  "I don't do a whole lot ... yet."
  [& args]
  (pprint (ns-publics 'intrinsic-function.core))
  #_(println "Hello, World!"))
