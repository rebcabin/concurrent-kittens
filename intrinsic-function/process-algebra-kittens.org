#+TODO: TODO BACKLOGGED(!) SCHEDULED(!) STARTED(!) SUSPENDED(!) BLOCKED(!) DELEGATED(!) ABANDONED(!) DONE

# FOR DOCUMENTATION OF THESE OPTIONS, see 12.2, Export Settings of the Org Info Manual

#+OPTIONS: ':t                # export smart quotes
#+OPTIONS: *:t                # export emphasized text
#+OPTIONS: -:t                # conversion of special strings
#+OPTIONS: ::t                # fixed-width sections
#+OPTIONS: <:t                # time/date active/inactive stamps
#+OPTIONS: \n:nil             # preserve line breaks
#+OPTIONS: ^:nil              # TeX-like syntax for sub- and super-scripts
#+OPTIONS: arch:headline      # archived trees
#+OPTIONS: author:t           # toggle inclusion of author name on export
#+OPTIONS: broken-links:mark  # ?
#+OPTIONS: c:nil              # clock keywords
#+OPTIONS: creator:nil        # other value is 'comment'

# Exporting of drawers

#+OPTIONS: d:t

# Exporting of drawers to LaTeX is NOT WORKING as of 25 March 2020. The
# workaround is to wrap the drawers in #+begin_example and #+end_example.

# #+OPTIONS: d:("LOGBOOK")      # drawers to include or exclude

#+OPTIONS: date:t             # ?
#+OPTIONS: e:t                # entities
#+OPTIONS: email:nil          # do or don't export my email
#+OPTIONS: f:t                # footnotes
#+OPTIONS: H:3                # number of headline levels to export
#+OPTIONS: inline:t           # export inline tasks?
#+OPTIONS: num:t              # section numbers
#+OPTIONS: p:nil              # toggle export of planning information
#+OPTIONS: pri:nil            # priority cookies
#+OPTIONS: prop:("ATTACH_DIR" "Attachments")           # include property drawers? or list to include?
#+OPTIONS: stat:t             # statistics cookies?
#+OPTIONS: tags:t             # org-export-with-tags? (what's a "tag"?)
#+OPTIONS: tasks:t            # include TODO items ("tasks" some complexity here)
#+OPTIONS: tex:t              # exports inline LaTeX
#+OPTIONS: timestamp:t        # creation timestamp in the exported file?
#+OPTIONS: toc:2              # set level limit in TOC or nil to exclude
#+OPTIONS: todo:t             # inclusion of actual TODO keyword
#+OPTIONS: |:t                # include tables

#+CREATOR: Emacs 26.2 of 2019-04-12, org version: 9.2.2

#+LaTeX_HEADER: \usepackage{bm}
#+LaTeX_HEADER: \usepackage[T1]{fontenc}
#+LaTeX_HEADER: \usepackage{cmll}
#+LaTeX_HEADER: \usepackage{amsmath}
#+LaTeX_HEADER: \usepackage{amssymb}
#+LaTeX_HEADER: \usepackage{interval}  % must install texlive-full
#+LaTeX_HEADER: \usepackage{mathtools}
#+LaTeX_HEADER: \usepackage{interval}  % must install texlive-full
#+LaTeX_HEADER: \usepackage[shortcuts]{extdash}
#+LaTeX_HEADER: \usepackage{tikz}
#+LaTeX_HEADER: \usepackage[utf8]{inputenc}

# #+LaTeX_HEADER: \usepackage[top=0.90in,bottom=0.55in,left=1.25in,right=1.25in,includefoot]{geometry}

#+LaTeX_HEADER: \usepackage[top=1.25in,bottom=1.25in,left=1.75in,right=1.75in,includefoot]{geometry}

#+LaTeX_HEADER: \usepackage{palatino}

#+LaTeX_HEADER: \usepackage{siunitx}
#+LaTeX_HEADER: \usepackage{braket}
#+LaTeX_HEADER: \usepackage[euler-digits,euler-hat-accent]{eulervm}
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \pagestyle{fancyplain}
#+LATEX_HEADER: \lhead{}
#+LATEX_HEADER: \chead{\textbf{(c) Brian Beckman, 2023; Creative Commons Attribution-ShareAlike CC-BY-SA}}
#+LATEX_HEADER: \rhead{}
#+LATEX_HEADER: \lfoot{(c) Brian Beckman, 2023; CC-BY-SA}
#+LATEX_HEADER: \cfoot{\thepage}
#+LATEX_HEADER: \rfoot{}
#+LATEX_HEADER: \usepackage{lineno}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{tipa}

# #+LATEX_HEADER: \linenumbers

#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \setlength{\parindent}{15pt}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \usepackage{textcomp}
#+LATEX_HEADER: \usepackage[atend]{bookmark}
#+LATEX_HEADER: \usepackage{mdframed}
#+LATEX_HEADER: \usepackage[utf8]{inputenc} % usually not needed (loaded by default)
#+LATEX_HEADER: \usepackage[T1]{fontenc}

#+LATEX_HEADER_EXTRA: \BeforeBeginEnvironment{minted}{\begin{mdframed}}
#+LATEX_HEADER_EXTRA: \AfterEndEnvironment{minted}{\end{mdframed}}
#+LATEX_HEADER_EXTRA: \bookmarksetup{open, openlevel=2, numbered}
#+LATEX_HEADER_EXTRA: \DeclareUnicodeCharacter{03BB}{$\lambda$}
# The following doesn't work: just search replace literal ESC=27=1B with ^[ !
# #+LATEX_HEADER_EXTRA: \DeclareUnicodeCharacter{001B}{xx}

#                                                    _
#  _ _  _____ __ __  __ ___ _ __  _ __  __ _ _ _  __| |___
# | ' \/ -_) V  V / / _/ _ \ '  \| '  \/ _` | ' \/ _` (_-<
# |_||_\___|\_/\_/  \__\___/_|_|_|_|_|_\__,_|_||_\__,_/__/

#+LaTeX_HEADER: \newcommand\definedas{\stackrel{\text{\tiny def}}{=}}
#+LaTeX_HEADER: \newcommand\belex{BELEX}
#+LaTeX_HEADER: \newcommand\bleir{BLEIR}
#+LaTeX_HEADER: \newcommand\llb{low-level \belex}
#+LaTeX_HEADER: \newcommand\hlb{high-level \belex}
#+LaTeX_HEADER: \newcommand{\Coloneqq}{\mathrel{\vcenter{\hbox{$:\,:\,=$}}{}}}

#+SELECT_TAGS: export
#+STARTUP: indent

#+LaTeX_CLASS_OPTIONS: [10pt,oneside,x11names]

#+LATEX: \setlength\parindent{0pt}

# #+STARTUP: latexpreview inlineimages showall
# #+STARTUP: showall

#+TITLE: Concurrent Kittens
#+AUTHOR: Brian Beckman
#+DATE: 24 Mar 2023

#+BEGIN_SRC elisp :exports none
  (setq org-babel-python-command "python3")
  (setq org-image-actual-width nil)
  (setq org-confirm-babel-evaluate nil)
  (setq org-src-fontify-natively t)
  (add-to-list 'org-latex-packages-alist '("" "listingsutf8"))
  (setq org-export-latex-listings 'minted)
  (setq org-latex-listings 'minted
        org-latex-packages-alist '(("" "minted"))
        org-latex-pdf-process
        '("pdflatex --synctex=1 -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex --synctex=1 -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex --synctex=1 -shell-escape -interaction nonstopmode -output-directory %o %f"))
  (org-babel-do-load-languages 'org-babel-load-languages
   '((ditaa . t) (latex . t)))
  (princ (concat (format "Emacs version: %s\n" (emacs-version))
                 (format "org version: %s\n" (org-version))))
#+END_SRC

#+RESULTS:
: Emacs version: GNU Emacs 28.2 (build 1, aarch64-apple-darwin21.1.0, NS appkit-2113.00 Version 12.0.1 (Build 21A559))
:  of 2022-09-12
: org version: 9.5.5

* Prologue

I must confess a mild mental disability: when I think about
mathematics or programs, I see little boats full of kittens
and other little boats.

=1+2*3=, five little kittens drowning in the sea. Venus rises on
her half-shell, fists full of bows and sterns in matching colors.
She reaches down and builds little boats, each from a bow and a
stern. She puts some little kittens in each boat. Sometimes, she
puts another little boat in a boat in place of a kitten.

She kisses the first kitten (or boat) in each boat and says
"You're the captain; take care of the others!" She blesses the
little boats and sinks back into the sea, leaving =(+ 1 (* 2 3))=
sailing safely on the waves.

Then again, who hasn't been burnt by C code like =x | y & z= or =x / y * z=? I
prefer to fully parenthesize all expressions.

Let's implement some fundamental terms from the rho calculus[fn:: Meredith, L. G.; Radestock, Mattias (22 December 2005). "A Reflective Higher-Order Calculus". Electronic Notes in Theoretical Computer Science. 141 (5): 49–67. doi:10.1016/j.entcs.2005.05.016.]
and the pi calculus[fn:PI: https://en.wikipedia.org/wiki/%CE%A0-calculus]
in a DSL[fn:: https://en.wikipedia.org/wiki/Domain-specific_language]
made of little boats, meaning "embedded in Clojure." Asynchronous
behavior is easy to model in Clojure, and we have
=clojure.spec=[fn:: https://clojure.org/guides/spec] for type
checking. Plus Clojure expressions look like little boats to save
the drowning kittens.

You say, "but you already have RhoLang! Why create something new?"
To save the kittens, and to avoid Scala.

# Clojure expressions look like little boats containing kittens or
# other little boats, with the first one being the captain of its
# boat.

** Why Not Scala?

You call up your friend Nancy and invite her to a party at your
house. She asks "Will Ted be there?" You think to yourself /what
fun!/ and innocently say, "Yes, I think so! I invited him!" Nancy
says "I'm terribly sorry, but I won't be able to make it to your
party. Please have a great time and give my best to everyone!"
Nancy hangs up and thinks to herself /except Ted/.

** Why Not Something Better?

Considered and rejected:

- Agda :: too obscure

- Haskell or Mathematica ::  no one else will use them

- Python :: well, ok, umm, never mind, no

- Common Lisp :: not modern.

- Racket :: designed for DSLs after all, but no one else uses it

- Coq :: full of rabbit holes -- otherwise lovely

- C++ ::  I would drive us both crazy.

There /is/ a path of least resistance for me, considering all
things.

** "Clojure doesn't have types!"

Not so. Clojure.spec[fn:: https://clojure.org/guides/spec] is at
least as strong as types. It's not static, that's true, but
=s/conform= /could/ be static.

Static or not hardly matters in our case. We can build little
boats on land before setting sail, or Venus will build them at sea
for us. We can check types, we can do rewriting, we can prove
theorems. It's good enough.

Also, Clojure is already in our toolchain. We use it for abstract
interpretation and test generation[fn:: https://github.com/rebcabin/asr-tester]
for lfortran and lpython.[fn:: https://github.com/lcompilers]

** How?

This is an executable document. When I produce a PDF from it, all
code blocks are executed and results reported. I like this better
than Jupyter notebooks for many reasons.

# , not least because I can
# define things in any order, say /after/ I use them. This document
# is an instance of Knuth's literate programming[fn::
# https://en.wikipedia.org/wiki/Literate_programming]. in
# org-babel.[fn:: https://orgmode.org/worg/org-contrib/babel/]

* $\Pi$ Kittens in Little Boats

#+begin_quote
/Each boat contains kittens and more little boats. We'll just say "kitten" and mean "an actual kitten or a little boat containing kittens or more little boats."/
#+end_quote

From the wiki page[fn:PI]

#+LaTeX_HEADER: \newcommand\napping    [0]{0}
#+LaTeX_HEADER: \newcommand\chatting   [3]{\bar{#1}\langle{#2}\rangle{}.\,#3}
#+LaTeX_HEADER: \newcommand\listening  [3]{#1(#2).\,#3}
#+LaTeX_HEADER: \newcommand\two        [2]{#1\mathrel{\vert}{#2}}
#+LaTeX_HEADER: \newcommand\whispering [2]{(\nu\,#1)\,{#2}}
#+LaTeX_HEADER: \newcommand\mama       [1]{!\,{#1}}

#+begin_export latex
\begin{equation}
\begin{array}{clll}
  P, Q & \Coloneqq \\
       & | \quad \napping            & \textrm{napping kitten}    & \textrm{do nothing; halt}                                   \\
       & | \quad \listening{x}{y}{P} & \textrm{listening kitten}  & \textrm{listen for channel }x\textrm{ on channel }y         \\
       & | \quad \chatting{x}{y}{P}  & \textrm{chatting kitten}   & \textrm{say "}y\textrm{" on channel }x\textrm{; don't wait} \\
       & | \quad \two{P}{Q}          & \textrm{two kittens}       & \textrm{run }P\textrm{ and }Q\textrm{ in parallel }         \\
       & | \quad \whispering{x}{P}   & \textrm{whispering kitten} & \textrm{fresh channel name }x\textrm{; use it in }P         \\
       & | \quad \mama{P}            & \textrm{mama cat}          & \textrm{run copies of }P\textrm{ forever} \\
\end{array}
\end{equation}
#+end_export

This is-low-level, like $\lambda$ calculus, only with concurrency
added. We'd have to build up numbers (like Church numerals),
Booleans, sets, functions, conditionals, loops, everything. We'll
do a little better, later. First, let's save some drowning
kittens!

** A Cartoon

Here is a tiny cartoon, again from the wiki page, showing a
reduction similar to an \eta\nobreakdash-reduction in \lambda
calculus:

#+begin_export latex
\begin{equation}
\begin{array}{clll}
  (\nu\,x) & (      & \chatting {x}{z}{\napping}  \\
           & \vert  & \listening{x}{y}{\chatting{y}{x}{\listening{x}{y}{\napping}}} \\
           & \vert  & \listening{z}{v}{\chatting{v}{v}{\napping}} \\
       {}  & )
\end{array}
\end{equation}
#+end_export

We have four drowning kittens. The first one is a whispering
kitten $\whispering{x}{P}$; she whispers "$x$" to the other three,
meaning "let's talk on channel $x$!" One might write:

#+begin_export latex
\begin{equation}
\whispering{x}{\left(
\begin{array}{clll}
 {}     & \chatting {x}{z}{\napping}  \\
 \vert  & \listening{x}{y}{\chatting{y}{x}{\listening{x}{y}{\napping}}} \\
 \vert  & \listening{z}{v}{\chatting{v}{v}{\napping}} \\
\end{array}\right)}
\end{equation}
#+end_export

This first kitten is going to be a boat containing the three
remaining kittens; "kitten" means "actual kitten or a boat
containing kittens."

One of the three remaining kittens is chatting on channel $x$ and
the other two are listening, one on $x$ and the other on $z$.
These three are doing their things two at a time,
$\two{P}{(\two{Q}{R})}$ or $\two{(\two{P}{Q})}{R}$, it doesn't
matter how you think about it ("associativity of /par/").

One kittens, $\chatting{x}{z}{0}$, chats on $x$, "hey, let's chat
on $z$!" Then she takes a nap. One of the other kittens,
$\listening{x}{y}{\cdots}$, and only one, is listening on $x$. She
says, "Oy! Here I am waiting on $x$ for someone to tell me where
(on what channel) to continue communicating, and I just heard 'on
$z$', so I'll switch there. After I switch, I'll have something to
say, but just let me switch, first!"

#+begin_export latex
\begin{equation}
\whispering{x}{\left(
\begin{array}{clll}
 {}     & \chatting {x}{z}{\napping}  \\
 {}     & \parallel \hspace{4.5pt} \downarrow \\
 \vert  & \listening{x}{y}{\chatting{y}{x}{\listening{x}{y}{\napping}}} \\
 {}     & \hspace{9.5pt}\downarrow\hspace{8.5pt}\downarrow\hspace{26.5pt}\downarrow \\
 \vert  & \listening{x}{z}{\chatting{z}{x}{\listening{x}{z}{\napping}}} \\
 \vert  & \listening{z}{v}{\chatting{v}{v}{\napping}} \\
\end{array}\right)}
\end{equation}
#+end_export

#+begin_export latex
\begin{equation}
\whispering{x}{\left(
\begin{array}{clll}
 {}     & \napping  \\
 \vert  & {\chatting{z}{x}{\listening{x}{z}{\napping}}} \\
 \vert  & \listening{z}{v}{\chatting{v}{v}{\napping}} \\
\end{array}\right)}
\end{equation}
#+end_export

See what happened? The first kitten said something and the second
kitten heard it. The "say prefix," before the dot of
$\chatting{x}{z}{0}$, got eaten up, and the "hear prefix," before
the dot of $(\listening{x}{y}{\cdots})$, got eaten up. Plus, $z$
got substituted for $y$ everywhere in
$(\listening{x}{y}{\cdots})$. That's "binding" $y$ to $z$.

I can't animate cartoons in a paper, but I visualize calculations
as symbols moving around in an animated cartoon. Such visualizing
saves me mistakes when doing the calculus. I do it with pen and
paper.

What if there were already some $z$'s in
$(\listening{x}{y}{\cdots})$? We'd have to patch that up first. It
doesn't matter what one names a channel, so long as the same
channel has the same name everywhere. We might rename preexisting
$z$'s something like $z_1$. We don't have that problem here, but
we might later. Our kittens always remember this duty to check for
existing names.

The second kitten $\chatting{z}{x}{\listening{x}{z}{\napping}}$
now says on $z$ "Switch to $x$, will you?" to whomever is
listening. Then she waits and listens on $x$. The third kitten
$\listening{z}{v}{\chatting{v}{v}{\napping}}$ is listening on $z$
for a channel that she temporarily is calling $v$, so she changes
$v$ to $x$, as she was told to do:

#+begin_export latex
\begin{equation}
\whispering{x}{\left(
\begin{array}{clll}
 {}     & \napping  \\
 \vert  & {\listening{x}{z}{\napping}} \\
 \vert  & {\chatting{x}{x}{\napping}} \\
\end{array}\right)}
\end{equation}
#+end_export

See how the $z$ chat-listen pair got eaten up and how $x$ got
substituted for $v$? If not, do an animation on paper.

The third kitten was listening on $z$ /for/ a new channel to
continue communicating on, but she didn't know what it was going
to be, so she temporarily called it $v$. Once she heard that $v$
is supposed to be $x$, she changed her next activity,
$\bar{v}\langle{v}\rangle$ to $\bar{x}\langle{x}\rangle$. She
didn't have to patch up any lingering $x$'s, but she remembers to
check.

Now the third kitten says "$x$" on $x$ and takes a nap without
waiting. The second kitten hears on $x$ that her temporary channel
name $z$ really should be $x$ again. She changes her $z$ to $x$,
notices she doesn't have any patching up or anything else to do,
and takes a nap. If you don't see it in your mind's eye, animate
it on paper.

#+begin_export latex
\begin{equation}
\whispering{x}{\left(
\begin{array}{clll}
 {}     & \napping   \\
 \vert  & {\napping} \\
 \vert  & {\napping} \\
\end{array}\right)}
\end{equation}
#+end_export

All the kittens are napping safely in the whisperer's boat.

** Telepathic Kittens

Several kittens used the same temporary names $z$ and $x$ at
various steps in this calculation, but it doesn't matter what each
one thinks to herself. They usually don't have to patch up names
that /other/ kittens are thinking about, only their own. This is
"the environment model for variables." Sometimes, kittens can be
telepathic and then they know some temporary names that other
kittens are thinking about. Those are "free variables." Telepathic
kittens have some patching up to do, also.

Also notice that every variable, $x, y, z$, stands in for a
communication channel. Sometimes we know what channel a variable
stands for, as when it's whispered or when it's to the right of a
"listening" dot. Other times, a variable stands for a channel
we'll find out about later. That's all we have so far:
channels, known or unknown.

** Bail the Boats!

For now, we've got all kittens safely napping in the "whisper"
boat. But they're not /dry/. They had to bail out a /lot/ of water
to keep from drowning. We'll fix that with some little boats
/inside/ the big "whisper" boat.

Venus first bails out most of the water, leaving little skeletal,
boats-in-progress --- ordinary mathematical function notation:

#+begin_export latex
\begin{equation}
\whispering{x}{\left(
\begin{array}{clll}
 {}     & \texttt{say} (x, z, \napping) \\
 \vert  & \texttt{hear}(x, y, \texttt{say}(y, x, \texttt{hear}(x, y, \napping))) \\
 \vert  & \texttt{hear}(z, v, \texttt{say}(v, v, \napping))
\end{array}\right)}
\end{equation}
#+end_export

There is still too much water, and kittens aren't inside boats!
Venus! Finish the boats:

#+LaTeX_HEADER: \newcommand\say [3]{\left(\texttt{say}\thickspace{}#1\thickspace{}#2\thickspace{}#3\right)}
#+LaTeX_HEADER: \newcommand\hear[3]{\left(\texttt{hear}\thickspace{}#1\thickspace{}#2\thickspace{}#3\right)}

#+begin_export latex
\begin{equation}
\whispering{x}{\left(
\begin{array}{clll}
 {}     & \say{x}{z}{\napping} \\
 \vert  & \hear{x}{y}{\say{y}{x}{\hear{x}{y}{\napping}}} \\
 \vert  & \hear{z}{v}{\say{v}{v}{\napping}}
\end{array}\right)}
\end{equation}
#+end_export

Everything must be a kitten or a boat, Venus! You're not done:

#+LaTeX_HEADER: \newcommand\parl[2]{\left(\texttt{par}\thickspace{}#1\thickspace{}#2\right)}

#+LaTeX_HEADER: \newcommand\kitA{\say{x}{z}{\napping}}
#+LaTeX_HEADER: \newcommand\kitB{\hear{x}{y}{\say{y}{x}{\hear{x}{y}{\napping}}}}
#+LaTeX_HEADER: \newcommand\kitC{\hear{z}{v}{\say{v}{v}{\napping}}}

\vskip 0.26cm
#+begin_src clojure :eval never
  (channel x
    (par (say x z 0)
         (par (hear x y
                (say y x
                  (hear x y 0)))
              (hear z v
               (say v v 0)))))
#+end_src

Hooray, all the kittens are safe and dry! But they can't nap, yet.
Venus, rearrange them so they can chat and nap!

\vskip 0.26cm
#+begin_src clojure :eval never
  (channel x
    (par (par (say  x z 0)  ;; Oooh!, x's line up!
              (hear x y
                    (say y x
                         (hear x y 0))))
         (hear z v
               (say v v 0))))
#+end_src

This is great because we have a rule that says whenever a =say=
and a =hear= line up their channels, we can substitute and gobble
up the =say= and =hear=:

\vskip 0.26cm
#+begin_src clojure :eval never
  (channel x
    (par (par 0
              (say z x
                   (hear x z 0)))
         (hear z v
               (say v v 0))))
#+end_src

Darn it! We must rearrange the =par='s again, but it's always OK
to do that:

\vskip 0.26cm
#+begin_src clojure :eval never
  (channel x
    (par 0
         (par (say  z x (hear x z 0))
              (hear z v (say v v 0)))))
#+end_src

Substitute and gobble:

\vskip 0.26cm
#+begin_src clojure :eval never
  (channel x
    (par 0
         (par (hear x z 0)
              (say  x x 0))))
#+end_src

One more time:

\vskip 0.26cm
#+begin_src clojure :eval never
  (channel x
    (par 0 (par 0 0)))
#+end_src

Inside a =par= boat, it doesn't matter whether you write =hear=
before =say= or =say= before =hear= -- =par= is commutative.

** Kitten Grammar

#+LaTeX_HEADER: \newcommand\knapping    [0]{\texttt{0}}
#+LaTeX_HEADER: \newcommand\kpar        [2]{\texttt{(par}\thickspace{}#1\thickspace{}#2\texttt{)}}
#+LaTeX_HEADER: \newcommand\kwhispering [2]{\texttt{(channel}\thickspace{}#1\thickspace{}#2\texttt{)}}
#+LaTeX_HEADER: \newcommand\kmama       [1]{\texttt{(repeat}\thickspace{}#1\texttt{)}}

#+begin_export latex
\begin{equation}
\begin{array}{clll}
  K, L & \Coloneqq \\
       & | \quad \napping             & \textrm{napping kitten}    & \textrm{do nothing; halt}                                   \\
       & | \quad \hear{x}{y}{K}       & \textrm{listening kitten}  & \textrm{listen for channel }x\textrm{ on channel }y         \\
       & | \quad \say{x}{y}{K}        & \textrm{chatting kitten}   & \textrm{say "}y\textrm{" on channel }x\textrm{; don't wait} \\
       & | \quad \kpar{K}{L}          & \textrm{two kittens}       & \textrm{run }K\textrm{ and }L\textrm{ in parallel }         \\
       & | \quad \kwhispering{x}{K}   & \textrm{whispering kitten} & \textrm{fresh channel name }x\textrm{; use it in }K         \\
       & | \quad \kmama{K}            & \textrm{mama cat}          & \textrm{run copies of }K\textrm{ forever} \\
\end{array}
\end{equation}
#+end_export

* Rewriting

All that was done with term rewriting[fn::
https://arxiv.org/pdf/1701.00638.pdf], a medium-sized theory with
unfinished edges. Our needs are very blue-collar.



** That's Calculus, not Programming

* Asynchrony

We can jump ahead and try Clojure's very blue-collar
/core.async/[fn:: https://clojuredocs.org/clojure.core.async]

** Listening Kitten

** Chatting Kitten

* Change Log

2023-26-Mar :: Current version.

2023-22-Mar :: Start.
